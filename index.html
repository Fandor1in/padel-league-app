<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Padel League Manager</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --color-primary: #208c85;
            --color-primary-hover: #1a6f6a;
            --color-background: #1a1a1a;
            --color-surface: #242424;
            --color-text: #e8e8e8;
            --color-text-secondary: #a0a0a0;
            --color-success: #32c794;
            --color-error: #ff5959;
            --color-border: #3a3a3a;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--color-background);
            color: var(--color-text);
            padding: 0;
            margin: 0;
            min-height: 100vh;
        }

        .app-container { display:flex; flex-direction:column; height:100vh; overflow:hidden; position:relative; }

        .main-app { display:flex; flex-direction:column; flex:1; overflow:hidden; }
        .main-app.hidden { display:none; }

        .start-screen { display:flex; flex:1; align-items:center; justify-content:center; padding:16px; margin:0 16px; }
        .start-screen.hidden { display:none; }

        .start-screen-card {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 14px;
            padding: 32px 28px;
            width: 100%;
            max-width: 360px;
            text-align: center;
        }

        .start-screen-icon { font-size:48px; margin-bottom:12px; display:block; }

        .header {
            background: var(--color-surface);
            border-bottom:1px solid var(--color-border);
            padding:16px;
            display:flex;
            align-items:center;
            justify-content:space-between;
            flex-shrink:0;
        }

        .header h1 { font-size:20px; font-weight:600; margin:0; }

        .nav-tabs {
            display:flex; gap:0; border-bottom:1px solid var(--color-border); background:var(--color-surface); flex-shrink:0;
        }

        .nav-tab {
            flex:1; padding:12px; text-align:center; border:none; background:none; color:var(--color-text-secondary);
            cursor:pointer; font-size:14px; font-weight:500; transition:all 0.2s; border-bottom:3px solid transparent;
        }
        .nav-tab.active { color:var(--color-primary); border-bottom-color:var(--color-primary); }
        .nav-tab:hover:not(.active) { color:var(--color-text); }

        .content { flex:1; overflow-y:auto; padding:16px; display:none; }
        .content.active { display:block; }

        .section { margin-bottom:24px; }
        .section-title {
            font-size:14px; font-weight:600; color:var(--color-text-secondary);
            text-transform:uppercase; margin-bottom:12px; letter-spacing:0.5px;
        }

        .card {
            background:var(--color-surface); border:1px solid var(--color-border); border-radius:8px; padding:12px; margin-bottom:12px;
        }

        .card-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
        .card-title { font-size:16px; font-weight:600; }
        .card-rank {
            background:var(--color-primary); color:white; width:32px; height:32px; border-radius:50%;
            display:flex; align-items:center; justify-content:center; font-weight:600; font-size:14px;
        }

        .card-stats {
            display:grid; grid-template-columns:1fr 1fr; gap:12px; font-size:13px;
        }

        .stat { display:flex; flex-direction:column; }
        .stat-label { color:var(--color-text-secondary); font-size:12px; margin-bottom:4px; }
        .stat-value { font-size:14px; font-weight:600; }

        .win-rate { color:var(--color-success); }

        .button {
            background:var(--color-primary); color:white; border:none; border-radius:6px; padding:12px 16px;
            font-size:14px; font-weight:600; cursor:pointer; transition:all 0.2s; width:100%; margin-top:12px;
        }
        .button:hover { background:var(--color-primary-hover); }
        .button:active { opacity:0.8; }

        .button--secondary {
            background:var(--color-surface); border:1px solid var(--color-border); color:var(--color-text);
        }
        .button--secondary:hover { background:var(--color-border); }

        .form-group { margin-bottom:12px; }
        .form-label { display:block; font-size:13px; margin-bottom:6px; font-weight:500; }
        .form-input {
            width:100%; padding:10px 12px; background:var(--color-background); border:1px solid var(--color-border);
            border-radius:6px; color:var(--color-text); font-size:14px;
        }
        .form-input:focus { outline:none; border-color:var(--color-primary); box-shadow:0 0 0 2px rgba(32,140,133,0.2); }

        .match-result {
            display:flex; align-items:center; justify-content:space-between; padding:12px; background:var(--color-background);
            border-radius:6px; margin-bottom:8px;
        }

        .match-teams { flex:1; }
        .team-name { font-size:13px; margin-bottom:2px; }
        .match-score { font-weight:600; min-width:40px; text-align:center; }

        .loading { text-align:center; color:var(--color-text-secondary); padding:24px; }
        .error {
            background:rgba(255,89,89,0.1); border:1px solid var(--color-error); border-radius:6px; padding:12px;
            color:var(--color-error); font-size:13px; margin-bottom:12px;
        }

        .empty-state { text-align:center; color:var(--color-text-secondary); padding:32px 16px; }
        .empty-state-icon { font-size:40px; margin-bottom:12px; opacity:0.5; }

        .modal { display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:1000; align-items:center; justify-content:flex-end; }
        .modal.active { display:flex; }

        .modal-content {
            background:var(--color-surface); width:100%; height:80vh; border-radius:16px 16px 0 0; display:flex; flex-direction:column; overflow:hidden;
        }
        .modal-header { border-bottom:1px solid var(--color-border); padding:16px; display:flex; justify-content:space-between; align-items:center; }
        .modal-body { flex:1; overflow-y:auto; padding:16px; }
        .close-btn { background:none; border:none; color:var(--color-text); font-size:24px; cursor:pointer; }

        @media (max-height:600px) { .modal-content { height:90vh; } }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üéæ Padel League</h1>
            <span id="playerName" style="font-size:12px; color:var(--color-text-secondary);">Loading...</span>
        </div>

        <div id="startScreen" class="start-screen hidden">
            <div class="start-screen-card">
                <span class="start-screen-icon">üëã</span>
                <h2>Welcome to Padel League</h2>
                <p style="margin-top:8px; margin-bottom:16px; color:var(--color-text-secondary); font-size:14px;">
                    Tap the button below to join the league and unlock the full menu.
                </p>
                <button id="startJoinBtn" class="button">Join League</button>
            </div>
        </div>

        <div id="mainApp" class="main-app">
            <div class="nav-tabs">
                <button class="nav-tab active" data-tab="standings">Standings</button>
                <button class="nav-tab" data-tab="matches">Matches</button>
                <button class="nav-tab" data-tab="profile">My Stats</button>
                <button class="nav-tab" data-tab="pairs">Pairs</button>
            </div>

            <!-- STANDINGS TAB -->
            <div id="standings" class="content active">
                <div class="loading" id="standingsLoading">Loading standings...</div>
                <div id="standingsContent" style="display:none;"></div>
            </div>

            <!-- MATCHES TAB -->
            <div id="matches" class="content">
                <div class="loading" id="matchesLoading">Loading matches...</div>
                <div id="matchesContent" style="display:none;"></div>
            </div>

            <!-- PROFILE TAB -->
            <div id="profile" class="content">
                <div class="loading" id="profileLoading">Loading profile...</div>
                <div id="profileContent" style="display:none;"></div>
            </div>

            <!-- PAIRS TAB -->
            <div id="pairs" class="content">
                <div class="section">
                    <div class="section-title">Available Partners</div>
                    <div class="loading" id="pairsLoading">Loading partners...</div>
                    <div id="pairsContent" style="display:none;"></div>
                </div>
                <div class="section">
                    <div class="section-title">My Pairs</div>
                    <div id="myPairsContent" style="display:none;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const AIRTABLE_BASE_ID = 'appUYjYuQQ7VS7SDx';
        const AIRTABLE_TOKEN = 'patiYOT8v7MoXXnOO.307f9867ded0c8341da4b99c55bf2983f503c6523dc8b0e77ef29c9f2e7c64e9';
        const AIRTABLE_PLAYERS_TABLE = 'Players';
        const AIRTABLE_MATCHES_TABLE = 'Matches';
        const AIRTABLE_PAIRS_TABLE = 'Pairs';
        const AIRTABLE_SETS_TABLE = 'setScores';
        const INITIAL_ELO = 1200;

        let currentUser = null;
        let allPlayers = [];
        let allMatches = [];
        let allPairs = [];
        let allSetScores = [];

        // Telegram WebApp init
        const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
        if (tg && typeof tg.ready === 'function') tg.ready();

        function getTelegramUser() {
            if (!tg) return null;
            if (tg.initDataUnsafe && tg.initDataUnsafe.user) return tg.initDataUnsafe.user;
            if (!tg.initData) return null;
            try {
                const params = new URLSearchParams(tg.initData);
                const userParam = params.get('user');
                if (!userParam) return null;
                return JSON.parse(decodeURIComponent(userParam));
            } catch (error) {
                console.warn('Unable to parse Telegram initData user', error);
                return null;
            }
        }

        async function init() {
            const user = getTelegramUser();
            if (user && user.id) {
                const displayName = user.username || user.first_name || 'Player';
                currentUser = { id: user.id, username: displayName };
            }

            try {
                const storedName = localStorage.getItem('padelLeagueDisplayName');
                const storedJoined = localStorage.getItem('padelLeagueJoined');
                if (storedName) {
                    if (!currentUser) currentUser = {};
                    currentUser.displayName = storedName;
                    if (storedJoined) currentUser.joined = true;
                }
                if (storedName) {
                    document.getElementById('playerName').textContent = storedName;
                } else if (currentUser && currentUser.username) {
                    document.getElementById('playerName').textContent = currentUser.username;
                } else {
                    document.getElementById('playerName').textContent = 'Guest';
                }
            } catch (e) {
                if (currentUser && currentUser.username) {
                    document.getElementById('playerName').textContent = currentUser.username;
                } else {
                    document.getElementById('playerName').textContent = 'Guest';
                }
            }

            await loadAllData();
            setupEventListeners();
        }

        async function loadAllData() {
            let error = null;
            try {
                const results = await Promise.all([
                    fetchAirtable(AIRTABLE_PLAYERS_TABLE),
                    fetchAirtable(AIRTABLE_MATCHES_TABLE),
                    fetchAirtable(AIRTABLE_PAIRS_TABLE),
                    fetchAirtable(AIRTABLE_SETS_TABLE)
                ]);
                allPlayers = results[0] || [];
                allMatches = results[1] || [];
                allPairs = results[2] || [];
                allSetScores = results[3] || [];
            } catch (err) {
                error = err;
                console.error('Error loading data:', err);
            } finally {
                renderStandings();
                renderMatches();
                renderProfile();
                renderPairs();
                updateStartScreenState();
                if (error) showGlobalError('Failed to load data. Please check your network or API settings.');
            }
        }

        function activateTab(tabName) {
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });
            document.querySelectorAll('.content').forEach(content => {
                content.classList.toggle('active', content.id === tabName);
            });
        }

        function hasExistingPlayerRecord() {
            if (!currentUser) return false;
            return allPlayers.some(player => {
                const fields = player.fields || {};
                const telegramIdMatch = fields['Telegram ID'] && currentUser && String(fields['Telegram ID']) === String(currentUser.id);
                const telegramUsernameMatch = fields['Telegram Username'] && currentUser && fields['Telegram Username'] === currentUser.username;
                const nameMatch = fields['Name'] && currentUser && fields['Name'] === currentUser.username;
                return telegramIdMatch || telegramUsernameMatch || nameMatch;
            });
        }

        function updateStartScreenState() {
            const startScreen = document.getElementById('startScreen');
            const mainApp = document.getElementById('mainApp');
            if (!startScreen || !mainApp) return;

            const joinedFlag = currentUser && (currentUser.joined || currentUser.displayName);
            const shouldShowStart = !hasExistingPlayerRecord() && !joinedFlag;
            if (shouldShowStart) {
                startScreen.classList.remove('hidden');
                mainApp.classList.add('hidden');
            } else {
                startScreen.classList.add('hidden');
                mainApp.classList.remove('hidden');
            }
        }

        function revealMainAppForJoin() {
            const startScreen = document.getElementById('startScreen');
            const mainApp = document.getElementById('mainApp');
            startScreen?.classList.add('hidden');
            mainApp?.classList.remove('hidden');
        }

        async function fetchAirtable(tableName) {
            try {
                const response = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${encodeURIComponent(tableName)}`, {
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_TOKEN}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (!response.ok) {
                    console.error(`Airtable GET error for ${tableName}`, response.status, data);
                    return [];
                }
                return data.records || [];
            } catch (error) {
                console.error(`Error fetching ${tableName}:`, error);
                return [];
            }
        }

        // improved create with error handling
        async function createAirtableRecord(tableName, fields) {
            const url = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${encodeURIComponent(tableName)}`;
            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ records: [{ fields }] })
                });
                const data = await response.json();
                console.debug('Airtable create response', { url, status: response.status, data });

                if (!response.ok) {
                    const message = data && data.error && data.error.message ? data.error.message : `HTTP ${response.status}`;
                    throw new Error(message);
                }
                if (!data.records) throw new Error('Unexpected response from Airtable (no records in response).');
                return data;
            } catch (error) {
                console.error(`Error creating record in ${tableName}:`, error);
                throw error;
            }
        }

        async function deleteAirtableRecord(tableName, recordId) {
            try {
                const response = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${encodeURIComponent(tableName)}/${recordId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${AIRTABLE_TOKEN}`,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                if (!response.ok) {
                    console.error('Airtable delete error', response.status, data);
                    throw new Error((data && data.error && data.error.message) || `HTTP ${response.status}`);
                }
                return data;
            } catch (error) {
                console.error(`Error deleting record ${recordId} in ${tableName}:`, error);
                throw error;
            }
        }

        function showGlobalError(message) {
            document.querySelectorAll('.loading').forEach(el => el.style.display = 'none');
            ['standingsContent', 'matchesContent', 'profileContent', 'pairsContent', 'myPairsContent'].forEach(id => {
                const el = document.getElementById(id);
                if (el) { el.innerHTML = '<div class="error">' + message + '</div>'; el.style.display = 'block'; }
            });
        }

        // Read rating from your Airtable schema. Prioritize "Individual Rating".
        function getPlayerRating(fields) {
            if (!fields) return INITIAL_ELO;
            const candidates = ['Individual Rating', 'Rating', 'Rating (ELO)', 'Initial Rating', 'RatingValue', 'rating', 'ELO'];
            for (const k of candidates) {
                if (Object.prototype.hasOwnProperty.call(fields, k)) {
                    const v = fields[k];
                    if (v === undefined || v === null || v === '') continue;
                    const n = Number(v);
                    if (!isNaN(n)) return n;
                    const parsed = parseFloat(String(v).replace(/[^\d.-]/g, ''));
                    if (!isNaN(parsed)) return parsed;
                }
            }
            // fallback: scan for any numeric field
            for (const key in fields) {
                const val = fields[key];
                if (val === undefined || val === null || val === '') continue;
                const num = Number(val);
                if (!isNaN(num)) return num;
            }
            return INITIAL_ELO;
        }

        function renderStandings() {
            const sorted = [...allPlayers].sort((a, b) => getPlayerRating(b.fields) - getPlayerRating(a.fields)).slice(0, 20);

            let html = '<div class="section">';
            if (sorted.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üìä</div><p>No players yet. Be the first to join!</p></div>';
            } else {
                sorted.forEach((player, idx) => {
                    const wins = player.fields.Wins || 0;
                    const losses = player.fields.Losses || 0;
                    const total = wins + losses;
                    const winRate = total > 0 ? ((wins / total) * 100).toFixed(0) : 0;
                    const rating = getPlayerRating(player.fields);

                    html += `
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">${player.fields.Name}</div>
                                <div class="card-rank">#${idx + 1}</div>
                            </div>
                            <div class="card-stats">
                                <div class="stat">
                                    <span class="stat-label">Individual Rating</span>
                                    <span class="stat-value" style="color: var(--color-primary);">${rating}</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-label">Win Rate</span>
                                    <span class="stat-value win-rate">${winRate}%</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-label">Wins</span>
                                    <span class="stat-value">${wins}</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-label">Losses</span>
                                    <span class="stat-value">${losses}</span>
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            html += '</div>';

            const container = document.getElementById('standingsContent');
            container.innerHTML = html;
            document.getElementById('standingsLoading').style.display = 'none';
            container.style.display = 'block';
        }

        function renderMatches() {
            let html = '<div class="section"><div class="section-title">Recent Matches</div>';

            if (allMatches.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üéæ</div><p>No matches recorded yet</p></div>';
            } else {
                allMatches.slice(0, 15).forEach(match => {
                    const team1 = match.fields['Team 1'] || match.fields['Team1'] || 'Team A';
                    const team2 = match.fields['Team 2'] || match.fields['Team2'] || 'Team B';
                    const score1 = match.fields['Score Team 1'] ?? match.fields['Score Team1'] ?? match.fields['Team 1 Score'] ?? match.fields['Team1 Score'] ?? 0;
                    const score2 = match.fields['Score Team 2'] ?? match.fields['Score Team2'] ?? match.fields['Team 2 Score'] ?? match.fields['Team2 Score'] ?? 0;
                    const date = match.fields['Match Date'] || match.fields['Date'] || 'TBD';

                    let setScoresText = '';
                    if (Array.isArray(allSetScores) && allSetScores.length > 0) {
                        const relatedSets = allSetScores.filter(setRecord => {
                            const link = setRecord.fields && (setRecord.fields['Match'] || setRecord.fields['match'] || setRecord.fields['Matches']);
                            if (Array.isArray(link)) return link.includes(match.id);
                            return link === match.id;
                        });
                        if (relatedSets.length > 0) {
                            const parts = relatedSets.map(setRecord => {
                                const f = setRecord.fields || {};
                                const s1 = f['Pair 1 Score'] ?? f['Pair 1 Score'] ?? f['Pair 1 Score'] ?? f['Pair 1 Score'] ?? '';
                                const s2 = f['Pair 2 Score'] ?? f['Pair 2 Score'] ?? f['Pair 2 Score'] ?? f['Pair 2 Score'] ?? '';
                                return `${s1}-${s2}`;
                            }).filter(Boolean);
                            setScoresText = parts.join(', ');
                        }
                    }

                    html += `
                        <div class="match-result">
                            <div class="match-teams">
                                <div class="team-name">${team1}</div>
                                <div class="team-name" style="color: var(--color-text-secondary); font-size:12px;">${date}</div>
                            </div>
                            <div class="match-score">${score1} - ${score2}</div>
                            <div class="match-teams" style="text-align:right;">
                                <div class="team-name">${team2}</div>
                            </div>
                            ${setScoresText ? `<div style="grid-column:1 / span 3; font-size:11px; color:var(--color-text-secondary); margin-top:4px;">Sets: ${setScoresText}</div>` : ''}
                        </div>
                    `;
                });
            }

            html += '</div>';

            const container = document.getElementById('matchesContent');
            container.innerHTML = html;
            document.getElementById('matchesLoading').style.display = 'none';
            container.style.display = 'block';
        }

        function renderProfile() {
            let html = '<div class="section"><div class="section-title">Your Statistics</div>';

            if (currentUser && allPlayers.length > 0) {
                const player = allPlayers.find(p => {
                    const fields = p.fields || {};
                    const idMatch = fields['Telegram ID'] && currentUser && String(fields['Telegram ID']) === String(currentUser.id);
                    const usernameMatch = fields['Telegram Username'] && currentUser && fields['Telegram Username'] === currentUser.username;
                    const displayNameMatch = fields['Name'] && currentUser && currentUser.displayName && fields['Name'] === currentUser.displayName;
                    return idMatch || usernameMatch || displayNameMatch;
                });

                if (player) {
                    const wins = player.fields.Wins || 0;
                    const losses = player.fields.Losses || 0;
                    const total = wins + losses;
                    const winRate = total > 0 ? ((wins / total) * 100).toFixed(0) : 0;
                    const rating = getPlayerRating(player.fields);
                    const rank = [...allPlayers].sort((a, b) => getPlayerRating(b.fields) - getPlayerRating(a.fields)).findIndex(p => p.id === player.id) + 1;

                    html += `
                        <div class="card">
                            <div class="card-header">
                                <div class="card-title">${player.fields.Name}</div>
                                <div class="card-rank">#${rank}</div>
                            </div>
                            <div class="card-stats">
                                <div class="stat">
                                    <span class="stat-label">Individual Rating</span>
                                    <span class="stat-value" style="color: var(--color-primary);">${rating}</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-label">Win Rate</span>
                                    <span class="stat-value win-rate">${winRate}%</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-label">Wins</span>
                                    <span class="stat-value">${wins}</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-label">Total Matches</span>
                                    <span class="stat-value">${total}</span>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    html += '<div class="empty-state"><div class="empty-state-icon">üë§</div><p>You haven\'t joined the league yet. Join now!</p></div>';
                }
            } else {
                html += '<div class="empty-state"><div class="empty-state-icon">üë§</div><p>Join the league to see your stats</p></div>';
            }

            html += '</div>';

            const container = document.getElementById('profileContent');
            container.innerHTML = html;
            document.getElementById('profileLoading').style.display = 'none';
            container.style.display = 'block';
        }

        function renderPairs() {
            const currentPlayer = currentUser ? allPlayers.find(p => {
                const fields = p.fields || {};
                const idMatch = fields['Telegram ID'] && currentUser && String(fields['Telegram ID']) === String(currentUser.id);
                const usernameMatch = fields['Telegram Username'] && currentUser && fields['Telegram Username'] === currentUser.username;
                const displayNameMatch = fields['Name'] && currentUser && currentUser.displayName && fields['Name'] === currentUser.displayName;
                return idMatch || usernameMatch || displayNameMatch;
            }) : null;

            const currentPlayerName = currentPlayer?.fields?.Name || currentUser?.displayName || currentUser?.username;
            const currentPlayerId = currentPlayer?.id;

            const playersById = allPlayers.reduce((acc, player) => {
                if (player.fields?.Name) acc[player.id] = player.fields.Name;
                return acc;
            }, {});

            const resolvePlayerName = (value) => {
                if (!value) return null;
                if (Array.isArray(value)) {
                    const resolved = value.map(val => playersById[val] || val).find(Boolean);
                    return resolved || null;
                }
                return playersById[value] || value;
            };

            const pairIncludesCurrentPlayer = (value) => {
                if (!value || !currentPlayerName) return false;
                if (Array.isArray(value)) {
                    if (currentPlayerId && value.includes(currentPlayerId)) return true;
                    return value.includes(currentPlayerName);
                }
                return value === currentPlayerName || value === currentPlayerId;
            };

            const availablePartners = currentPlayerName ? allPlayers.filter(p => p.fields.Name !== currentPlayerName) : allPlayers;

            const userPairs = currentPlayerName ? allPairs.filter(pair =>
                pairIncludesCurrentPlayer(pair.fields['Player 1']) ||
                pairIncludesCurrentPlayer(pair.fields['Player 2'])
            ) : [];

            let partnersHtml = '<div class="section">';
            if (!currentPlayer) {
                partnersHtml += '<div class="empty-state"><div class="empty-state-icon">ü§ù</div><p>Join the league first to create pairs</p></div>';
            } else if (availablePartners.length === 0) {
                partnersHtml += '<div class="empty-state"><div class="empty-state-icon">ü§ù</div><p>No other players available yet</p></div>';
            } else {
                availablePartners.forEach(partner => {
                    const partnerRating = getPlayerRating(partner.fields);
                    const currentRating = getPlayerRating(currentPlayer.fields);
                    const diff = Math.abs(partnerRating - currentRating);

                    partnersHtml += `
                        <div class="card">
                            <div class="card-header">
                                <div>
                                    <div class="card-title">${partner.fields.Name}</div>
                                    <div style="font-size:12px; color:var(--color-text-secondary); margin-top:4px;">Individual Rating: ${partnerRating} (Diff: ${diff})</div>
                                </div>
                            </div>
                            <button class="button" onclick="createPair('${currentPlayerName}', '${partner.fields.Name}')">Create Pair</button>
                        </div>
                    `;
                });
            }
            partnersHtml += '</div>';

            let myPairsHtml = '';
            if (userPairs.length === 0) {
                myPairsHtml = '<div class="empty-state"><div class="empty-state-icon">üë•</div><p>No active pairs yet</p></div>';
            } else {
                userPairs.forEach(pair => {
                    const player1Name = resolvePlayerName(pair.fields['Player 1']);
                    const player2Name = resolvePlayerName(pair.fields['Player 2']);
                    const partnerName = player1Name === currentPlayerName ? player2Name : player1Name;
                    const createdDate = pair.fields['Created'] || pair.fields['Created Date'] || 'Today';

                    myPairsHtml += `
                        <div class="card">
                            <div class="card-header">
                                <div>
                                    <div class="card-title">You & ${partnerName || 'Partner'}</div>
                                    <div style="font-size:12px; color:var(--color-text-secondary); margin-top:4px;">${createdDate}</div>
                                </div>
                            </div>
                            <button class="button button--secondary" onclick="removePair('${pair.id}')">Remove Pair</button>
                        </div>
                    `;
                });
            }

            document.getElementById('pairsContent').innerHTML = partnersHtml;
            document.getElementById('pairsContent').style.display = 'block';
            document.getElementById('pairsLoading').style.display = 'none';
            document.getElementById('myPairsContent').innerHTML = myPairsHtml;
        }

        function setupEventListeners() {
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', () => activateTab(tab.dataset.tab));
            });

            const startJoinBtn = document.getElementById('startJoinBtn');
            if (startJoinBtn) {
                startJoinBtn.addEventListener('click', async () => await joinLeagueFromStart(startJoinBtn));
            }
        }

        // Join flow from start screen (do not send rating field)
        async function joinLeagueFromStart(buttonEl) {
            try {
                let displayName = (currentUser && (currentUser.username || currentUser.displayName)) || 'Player';
                if (!currentUser || !currentUser.id) displayName = displayName + '-' + Date.now().toString().slice(-4);

                if (hasExistingPlayerRecord()) {
                    currentUser = currentUser || {};
                    currentUser.displayName = displayName;
                    currentUser.joined = true;
                    try { localStorage.setItem('padelLeagueDisplayName', displayName); localStorage.setItem('padelLeagueJoined', 'true'); } catch (e) {}
                    revealMainAppForJoin();
                    activateTab('standings');
                    await loadAllData();
                    return;
                }

                const prevText = buttonEl.innerHTML;
                buttonEl.disabled = true;
                buttonEl.innerHTML = 'Joining...';

                // Only send fields that exist in your schema: Name, Wins, Losses, Games Played, Telegram ID, Telegram Username
                const fieldsToCreate = {
                    'Name': displayName,
                    'Wins': 0,
                    'Losses': 0,
                    'Games Played': 0
                };
                if (currentUser && currentUser.id) fieldsToCreate['Telegram ID'] = Number(currentUser.id);
                if (currentUser && currentUser.username) fieldsToCreate['Telegram Username'] = currentUser.username;

                const res = await createAirtableRecord(AIRTABLE_PLAYERS_TABLE, fieldsToCreate);
                console.debug('Create player result', res);

                if (res && res.records && res.records.length > 0) {
                    currentUser = currentUser || {};
                    currentUser.displayName = displayName;
                    currentUser.joined = true;
                    try { localStorage.setItem('padelLeagueDisplayName', displayName); localStorage.setItem('padelLeagueJoined', 'true'); } catch (e) {}
                    await loadAllData();
                    revealMainAppForJoin();
                    activateTab('standings');
                } else {
                    alert('Unable to create player record. Please try again.');
                }
                buttonEl.disabled = false;
                buttonEl.innerHTML = prevText;
            } catch (err) {
                console.error('Error joining league:', err);
                const msg = (err && err.message) ? err.message : 'Error while joining the league. Check console for details.';
                alert('Join failed: ' + msg);
                if (buttonEl) { buttonEl.disabled = false; buttonEl.innerHTML = 'Join League'; }
            }
        }

        // Basic pair creation/removal (keeps UI functional). Note: Airtable link fields generally prefer record IDs.
        async function createPair(playerAName, playerBName) {
            try {
                if (!playerAName || !playerBName) { alert('Missing player names for pair creation.'); return; }
                const fields = {
                    'Player 1': playerAName,
                    'Player 2': playerBName,
                    'Created': new Date().toISOString()
                };
                await createAirtableRecord(AIRTABLE_PAIRS_TABLE, fields);
                await loadAllData();
                activateTab('pairs');
            } catch (err) {
                console.error('Error creating pair:', err);
                alert('Failed to create pair: ' + (err.message || 'unknown error'));
            }
        }

        async function removePair(pairId) {
            try {
                if (!pairId) return;
                await deleteAirtableRecord(AIRTABLE_PAIRS_TABLE, pairId);
                await loadAllData();
            } catch (err) {
                console.error('Error removing pair:', err);
                alert('Failed to remove pair: ' + (err.message || 'unknown error'));
            }
        }

        // Start
        init();
    </script>
</body>
</html>
